**[참고&출처: robinyeon님](https://github.com/robinyeon/TIL/blob/main/BOOKS/%ED%81%B4%EB%A6%B0%20%EC%BD%94%EB%93%9C(Clean%20Code).md)**

# [클린 코드(Clean Code)](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=34083680)

## 목차
1. [추천사 & 들어가면서](#추천사-&-들어가면서)
2. [깨끗한 코드](#1장-깨끗한-코드)
3. [의미 있는 이름](#2장-의미-있는-이름)
4. [함수](#3장-함수)
5. [주석](#4장-주석)
6. [형식 맞추기](#5장-형식-맞추기)
7. [객체와 자료 구조](#6장-객체와-자료-구조)
8. [오류 처리](#7장-오류-처리)

<br/>

## 추천사 & 들어가면서
### 기억하고 싶은 책 내용
- 사소한 곳에서 발휘하는 정직은 사소하지 않다 -덴마크 속담 (p.xxii)
- 품질은 하늘에서 뚝 떨어진 위대한 방법론이 아니라 사심없이 기울이는 무수한 관심에서 얻어진다. (p.xxvii)

### 소감 및 생각
- 새벽에 일어나버려서 본의아니게 일찍 해버렸네..
- [robinyeon님 정리](https://github.com/robinyeon/TIL/blob/main/BOOKS/%ED%81%B4%EB%A6%B0%20%EC%BD%94%EB%93%9C(Clean%20Code).md)가 엄청남!

### 새롭게 배운 개념
- [메타포](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=semisun7021&logNo=70123000137): 익숙한 개념으로 익숙하지 않은 개념을 이해시키기위해 연결하는 것
- [애자일](https://gdtbgl93.tistory.com/127)
  - 스크럼(Scrum)
    - 애자일 방법론에는 스크럼, 칸반, XP 등 여러 방식이 존재하며 각자 다른 목적에 특화되어 있다.
    - 그 중 스크럼은 유지보수 보다는 개발에 초점이 맞추어진 애자일 방법론이다.
  - 백로그(Backlog)
    - 사용자를 조사하여 구현해야 할 사항을 정의한 문서: 제품 백로그 -> 스프린트 백로그
- [린(Lean)](http://www.incodom.kr/%EB%A6%B0_%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4_%EA%B0%9C%EB%B0%9C%EB%B0%A9%EB%B2%95%EB%A1%A0)
  - 낭비에 포커스를 두어 프로그램을 개발하는데 발생할 수 있는 모든 낭비를 최소화하고 결과를 측정, 성과를 분석하여 소프트웨어 가치를 최대화하고자 하는 것을 목표로 둔다.
    - 애자일 방법론 : 개인별 또는 팀 간에 고객과 협업하고 빠른 개발을 수행(고객과 협업)
    - 린 개발 방법론 : 고객 관점에서 전체 프로세스상에서 낭비를 제거하여 고객 가치를 높이는 것에 우선순위(전적으로 고객 관점)

<br/>

## 1장. 깨끗한 코드
### 기억하고 싶은 책 내용
- TDD라는 분야는 우리 업계에 심오한 영향을 미치면서 오늘날 가장 근본적인 원칙 중 하나가 되었다. 테스트 케이스가 없는 코드는 깨끗한 코드가 아니다. 아무리 코드가 우아해도, 아무리 가독성이 높아도, 테스트 케이스가 없으면 깨끗하지 않다. (p.12)
- 새 코드를 짜면서 우리는 끊임없이 기존 코드를 읽는다.
- 비율이 이렇게 높으므로 읽기 쉬운 코드가 매우 중요하다. 기존 코드를 읽어야 새 코드를 짜므로 읽기 쉽게 만들면 사실은 짜기도 쉬워진다. (p.18)
- 캠프장은 처음 왔을 때보다 더 깨끗하게 해놓고 떠나라. (p.19)
- 처음 왔을 때보다 더 나은 세상을 만들고 떠나려 노력하라. (p.19)
- **"연습해, 연습!"** (p.20)

### 소감 및 생각
> 헛소리! 앞으로 코드가 사라질 가망은 전혀 없다! 왜? 코드는 요구사항을 상세히 표현하는 수단이니까! (p.2)
- 당장 실직 전망이 아니라 다행인 말이기는 한데, 의미는 알겠지만, 이렇게 단정적으로 말하면 다른 방법은 생각도 안해보고 있는거 같아서 불안하다..
> 대다수의 관리자는 진실을 원한다. 일정에 쫓기더라도 대다수 관리자는 좋은 코드를 원한다. 그들이 일정과 요구사항을 강력하게 밀어붙이는 이유는 그것이 그들의 책임이기 때문이다. 좋은 코드를 사수하는 일은 바로 우리 프로그래머들의 책임이다. (p.7)
- 그런데 관리자를 설득하는게 더 힘들어서 그냥 맞춰주는 경우가 많은듯.. 스스로 확신이 부족해서 그런걸까...

### 새롭게 배운 개념
- 르블랑의 법칙: 나중은 절대 돌아오지 않는다는 법칙
- [메서드 추출](https://armadillo-dev.github.io/book/refactoring-06-composing-methods/#:~:text=1.%20%EB%A9%94%EC%84%9C%EB%93%9C%20%EC%B6%94%EC%B6%9C,Permalink): 가장 많이 사용하는 기법으로, 메서드가 너무 길거나 코드에 주석을 달아야만 의도를 이해할 수 있을 때 그 코드를 별도의 메서드로 만든다. 이 때 메서드 명은 원리가 아닌 기능을 나타내는 이름으로 짓는다.
- [익스트림 프로그래밍(eXtreme Programming)(XP)](https://wooaoe.tistory.com/33#:~:text=%EB%B6%88%EC%96%B4%EB%84%A3%EC%96%B4%20%EC%A4%80%EB%8B%A4%EA%B3%A0%20%EB%A7%90%ED%95%98%EC%98%80%EB%8B%A4.%C2%A0-,eXtream%20Programming(XP),-%3F%C2%A0%C2%A0%0A%EB%AF%B8%EB%9E%98%EC%97%90%20%EB%8C%80%ED%95%9C%20%EC%98%88%EC%B8%A1%EC%9D%84): 미래에 대한 예측을 최대한 하지 않고, 지속적으로 프로토타입을 완성하는 애자일 방법론 중 하나이다. 이 방법론은 추가 요구사항이 생기더라도, 실시간으로 반영할 수 있다.

<br/>

## 2장. 의미 있는 이름
### 기억하고 싶은 책 내용
- 이름은 다음과 같은 질문에 모두 답해야 한다. **존재 이유는? 수행 기능은? 사용 방법은?** 따로 주석이 필요하다면 의도를 분명히 드러내지 못했다는 말이다. (p.22)
- 실제 컨테이너가 List인 경우라도 컨테이너 유형을 이름에 넣지 않는 편이 바람직하다. (p.24)
- 클래스, 객체 이름은 명사나 명사구가 적합하다. (p.32)
- 메서드 이름은 동사나 동사구가 적합하다. (p.32)
- Constructor를 Overload할 때는 정적 팩토리 메서드를 사용한다. 메서드는 인수를 설명하는 이름을 사용한다. (p.32)
    ```java
    Complex fulcrumPoint = Complex.FromRealNumber(23.0);
    ```
- 프로그래머는 코드를 최대한 이해하기 쉽게 짜야 한다. 집중적인 탐구가 필요한 코드가 아니라 대충 훑어봐도 이해할 코드 작성이 목표다. (p.34)
- 맥락을 부여한다. 변수가 좀 더 큰 구조에 속한다는 사실이 독자에게는 분명해진다. 물론 Address라는 클래스를 생성하면 컴파일러에게도 분명해진다. (p.35)
- 이름에 불필요한 맥락을 추가하지 않도록 주의한다. (p.37)
- 암기는 도구에게 맡기고, 우리는 문장이나 문단처름 읽히는 코드 아니면 적어도 표나 자료 구조처럼 읽히는 코드를 짜는 데만 집중해야 마땅하다. (p.38)

### 소감 및 생각
- List, -Data, -Info 자주 썼는데... OTL
- 이래저래 영어공부가 필수인가..

### 궁금한 내용, 잘 이해되지 않는 내용
- [VISITOR 패턴](https://dailyheumsi.tistory.com/216) 작업 대상(방문 공간) 과 작업 항목(방문 공간을 가지고 하는 일)을 분리시킨 패턴

<br/>

## 3장. 함수
### 기억하고 싶은 책 내용
- if/else, while 등에 들어가는 블록은 한 줄이어야 한다. 대게 거기서 함수를 호출한다. 그러면 enclosing function이 작아질 뿐 아니라, 블록 안에서 호출하는 함수 이름을 적절히 짓는다면, 코드를 이해하기도 쉬워진다.
  이 말은 중첩 구조가 생길만큼 함수가 커져서는 안 된다는 뜻이다. 그러므로 함수에서 들여쓰기 수준은 1단이나 2단을 넘어서면 안 된다. 당연한 말이지만, 그래야 함수는 읽고 이해하기 쉬워진다. (43)
- 단순히 다른 표현이 아니라 의미 있는 이름으로 다른 함수를 추출할 수 있다면 그 함수는 여러 작업을 하는 셈이다. (45)
- 함수가 확실히 '한 가지' 작업만 하려면 함수 내 모든 문장의 추상화 수준이 동일 해야 한다. (45)
- 코드는 위에서 아래로 이야기처럼 읽혀야 좋다. 한 함수 다음에는 추상화 수준이 한 단계 낮은 함수가 온다. 나는 이것을 내려가기 구칙이라 부른다. (46)
- 서술적인 이름을 사용하라! (49)
- 서술적인 이름을 사용하면 개발자 머릿속에서도 설계가 뚜렷해지므로 코드를 개선하기 쉬워진다. (49)
- 함수에서 이상적인 인수 개수는 0개다. (50)
- 부수 효과를 일으키지 마라! 많은 경우 시간적인 결합 temporal coupling 이나 순서 종속성 order dependency를 초래한다. (54)
- 오류 처리도 한 가지 작업이다. (59)

### 소감 및 생각, 궁금한 내용, 잘 이해되지 않는 내용
- 그런데 가끔 함수를 엄청 쪼개놨는데, 이름으로 어떤 함수인지 바로 파악이 안되면, 쪼갠 함수 일일히 들어가서 확인하고 오느라 파악이 더 오래 걸린다.
- OOP가 아니어도 모두 완벽하게 유효한 조언일까? 맞다면 사례는? 아니라면 어떤면에서?


<br/>

## 4장. 주석
### 기억하고 싶은 책 내용
- 주석이 필요한 상황에 처하면 곰곰이 생각하기 바란다. 상황을 역전해 코드로 표현할 방법은 없을까? (68)
- 좋은 주석: 의도를 설명하는 주석 - 때때로 주석은 구현을 이해하게 도와주는 선을 넘어 결정에 깔린 의도까지 설명한다. (71)
- 좋은 주석: 결과를 경고하는 주석 - ex) ~은 스레드에 안전하지 못하여, 각 인스턴스를 독립적으로 생성해야 한다. (73)

### 소감 및 생각, 궁금한 내용, 잘 이해되지 않는 내용
- 주석 싫어하는 사람들이 많아서, todo 말고 다 지우고 커밋했었는데, 필요한 주석이 있기는 있었구나... todo랑 경고주석은 남겨둘걸 그랬나..


<br/>

## 5장. 형식 맞추기
### 기억하고 싶은 책 내용
- 오랜 시간이 지나 원래 코드의 흔적을 더 이상 찾아보기 어려울 정도로 코드가 바뀌어도 맨 처음 잡아놓은 구현 스타일과 가독성 수준은 유지보수 용이성과 확정성에 계속 영향을 미친다. (96)
- 일련의 행 묶음은 완결된 생각 하나를 표현한다. (98)
- 시스템이 무엇을 하는지 이해하고 싶은데, 이 조각 저 조각이 어디에 있는지 찾고 기억하느라 시간과 노력을 소모한다. (101)
- 변수는 사용하는 위치에 최대한 가까이 선언한다. (101)
- 반면, 인스턴스 변수는 클래스 맨 처음에 선언한다. (103)

### 소감 및 생각, 궁금한 내용, 잘 이해되지 않는 내용
> 한 함수가 다른 함수를 호출한다면 두 함수는 세로로 가까이 배치한다. 또한 가능하다면 호출하는 함수를 호출되는 함수보다 먼저 배치한다. 그러면 프로그램이 자연스럽게 읽힌다. (104)
앞에 놔야하나 뒤에 놔야하나 우왕좌왕했는데, 이제 금방 정할 수 있겠다.

### 새롭게 배운 개념
- 일반적으로 C++ 에서는 모든 [인스턴스 변수](https://bit.ly/3s8Rv98)를 클래스 마지막에 선언한다는 [소위 가위규칙(scissors rule)](http://kastalien.org/wp/?p=128)을 적용한다.

<br/>

## 6장. 객체와 자료 구조
### 기억하고 싶은 책 내용
- 변수를 private으로 선언하더라도 각 값마다 get 함수와 set 함수를 제공한다면 구현을 외부로 노출하는 셈이다. (118)
- 변수 사이에 함수라는 계층을 넣는다고 구현이 저절로 감춰지지는 않는다. 추상 인터페이스를 제공해 사용자가 구현을 모른 채 자료의 핵심을 조작할 수 있어야 진정한 의미의 클래스다. (119)
- 자료를 세세하게 공개하기보다는 추상적인 개념으로 표현하는 편이 좋다. 인터페이스나 get/set 함수만으로는 추상화가 이뤄지지 않는다. 개발자는 객체가 포함하는 자료를 표현 할 가장 좋은 방법을 심각하게 고민해야 한다. (119)
- 객체와 자료 구조 사이에 벌어진 차이를 보여준다. 객체는 추상화 뒤로 자료를 숨긴 채 자료를 다루는 함수만 공개한다. 자료 구조는 자료를 그대로 공개하며 벌댜른 함수는 제공하지 않는다. (119)
- (자료 구조를 사용하는) 절차적인 코드는 기존 자료 구조를 변경하지 않으면서 새 함수를 추가하기 쉽다. 반면, 객체 지향 코드는 기존 함수를 변경하지 않으면서 새 클래스를 추가하기 쉽다. (122)
- ctxt가 객체라면 **뭔가를 하라고** 말해야지 속을 드러내라고 말하면 안 된다. (125)
- 자료 구조체(자료 전달 객체, Data Transfer Object, DTO)의 전형적인 형태는 공개 변수만 있고 함수가 없는 클래스다. DB와 통신하거나, 소켓에서 받은 메시지의 구문을 분석할 때 유용하다. (126)
- 점 더 일반적인 형태는 'Bean'구조다. 빈은 private 변수를 get/set 함수로 조작한다. 일종의 사이비 캡슐화로, 일부 OO순수주의자나 만족시킬 뿐 별다른 이익을 제공하지 않는다. (126)
- 활성 레코드는 DTO의 툭수한 형태다. 활성 레코드는 자료 구조로 취급한다. 비지니스 규칙을 담으면서 내부 자료를 숨기는 객체는 따로 생성한다. (127)
- **객체**는 동작을 공개하고 자료를 숨긴다. 그래서 기존 동작을 변경하지 않으면서 새 객체 타입을 추가하기는 쉬운 반면, 기존 객체에 새 동작을 추가하기는 어렵다. **자료 구조**는 별다른 동작 없이 자료를 노출한다. 그래서 기존 자료 구조에 새 동작을 추가하기는 쉬우나, 기존 함수에 새 자료 구조를 추가하기는 어렵다. (127)
- 시스템을 구현할 때, 새로운 자료 타입을 추가하는 유연성이 필요하면 객체가 더 적합하다. 다른 경우로 새로운 동작을 추가하는 유연성이 필요하면 자료 구조와 절차적인 코드가 더 적합하다. (128)

### 소감 및 생각, 궁금한 내용, 잘 이해되지 않는 내용
- 노련한 객체 지향 설계자는 VISITOR 혹은 Dual-Patch 등과 같이 잘 알려진 기법을 사용해 이 문제를 해결한다. 하지만 이들 기법 역시 대가가 따르며, 일반적으로 절차적인 프로그램에서 볼 수 있는 구조를 반환한다. (옮긴이) VISITOR 패턴은 주로 상속 없이 클래스에 메서드를 효과적으로 추가하기 위해 사용한다. 하지만 합성 객체의 내부 구조가 VISITOR에 열리게 되므로 캡슐화를 위반한다는 문제점이 생긴다. (121)
- **디미터 법칙**은 잘 알려진 heuristic으로, 모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다는 법칙이다. 좀 더 정확히 표현하자면, 디미터 법칙은 "클래스 C의 메서드 f는 다음과 같은 객체의 메서드만 호출해야 한다"고 주장한다.
  - 클래스 C
  - f가 생성한 객체
  - f 인수로 넘어온 객체
  - C 인스턴스 변수에 저장된 객체 (123)
- train wreck 예) final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath(); (123)

### 새롭게 배운 개념
- [디미터 법칙](https://tecoble.techcourse.co.kr/post/2020-06-02-law-of-demeter/): 객체 간 관계를 설정할 때 객체 간의 결합도를 효과적으로 낮출 수 있는 유용한 지침 중 하나.
  - 다른 객체들과의 협력을 통해 프로그램을 완성해나가는 객체지향 프로그래밍에서 객체들의 협력 경로를 제한하면 결합도를 효과적으로 낮출 수 있다


<br/>

## 7장. 오류 처리
### 기억하고 싶은 책 내용
### 소감 및 생각
### 새롭게 배운 개념
### 궁금한 내용, 잘 이해되지 않는 내용


<hr/>

*Form*
### 기억하고 싶은 책 내용
### 소감 및 생각
### 새롭게 배운 개념
### 궁금한 내용, 잘 이해되지 않는 내용

<br/>

#노마드클럽 #북클럽 #노개북


**[참고&출처: robinyeon님](https://github.com/robinyeon/TIL/blob/main/BOOKS/%ED%81%B4%EB%A6%B0%20%EC%BD%94%EB%93%9C(Clean%20Code).md)**